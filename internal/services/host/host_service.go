package host

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
)

// HostService handles business logic for host management
type HostService struct {
	hostRepo       repository.HostRepository
	agentMgr       *AgentManager
	stateCollector *StateCollector
	serverURL      string // Server URL for agent installation script (HTTP)
	grpcAddr       string // gRPC server address for agent connection (host:port)
}

// NewHostService creates a new HostService
func NewHostService(hostRepo repository.HostRepository, agentMgr *AgentManager, stateCollector *StateCollector, serverURL string, grpcAddr string) *HostService {
	return &HostService{
		hostRepo:       hostRepo,
		agentMgr:       agentMgr,
		stateCollector: stateCollector,
		serverURL:      serverURL,
		grpcAddr:       grpcAddr,
	}
}

// GetAgentManager returns the agent manager instance
func (s *HostService) GetAgentManager() *AgentManager {
	return s.agentMgr
}

// CreateHost creates a new host node with generated secret key
func (s *HostService) CreateHost(ctx context.Context, host *models.HostNode) error {
	// UUID is automatically generated by BaseModel

	// Generate secret key
	secretKey, err := s.generateSecretKey()
	if err != nil {
		return fmt.Errorf("failed to generate secret key: %w", err)
	}
	host.SecretKey = secretKey // TODO: Encrypt with AES-256

	// Create the host
	if err := s.hostRepo.Create(ctx, host); err != nil {
		return fmt.Errorf("failed to create host: %w", err)
	}

	return nil
}

// GetHost retrieves a host by ID with online status
func (s *HostService) GetHost(ctx context.Context, id uuid.UUID) (*models.HostNode, error) {
	host, err := s.hostRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Enrich with runtime data
	s.enrichHostWithRuntimeData(host)

	return host, nil
}

// ListHosts retrieves a list of hosts with filters
func (s *HostService) ListHosts(ctx context.Context, filter repository.HostFilter) ([]*models.HostNode, int64, error) {
	hosts, total, err := s.hostRepo.List(ctx, filter)
	if err != nil {
		return nil, 0, err
	}

	// Enrich each host with runtime data
	for _, host := range hosts {
		s.enrichHostWithRuntimeData(host)
	}

	return hosts, total, nil
}

// UpdateHost updates a host node
func (s *HostService) UpdateHost(ctx context.Context, host *models.HostNode) error {
	// Don't allow updating ID or secret key through this method
	existingHost, err := s.hostRepo.GetByID(ctx, host.ID)
	if err != nil {
		return err
	}

	// Preserve ID and secret key
	host.ID = existingHost.ID
	host.SecretKey = existingHost.SecretKey

	return s.hostRepo.Update(ctx, host)
}

// DeleteHost deletes a host node
func (s *HostService) DeleteHost(ctx context.Context, id uuid.UUID) error {
	// Get the host to find its ID
	host, err := s.hostRepo.GetByID(ctx, id)
	if err != nil {
		return err
	}

	// Disconnect the agent if online
	if s.agentMgr.IsAgentOnline(host.ID.String()) {
		s.agentMgr.DisconnectAgent(host.ID.String())
	}

	// Delete the host
	return s.hostRepo.Delete(ctx, id)
}

// GetAgentInstallCommand generates the agent installation command
func (s *HostService) GetAgentInstallCommand(ctx context.Context, id uuid.UUID) (string, error) {
	host, err := s.hostRepo.GetByID(ctx, id)
	if err != nil {
		return "", err
	}

	// Generate installation command
	// Note: serverURL is HTTP URL for downloading the install script
	// grpcAddr is the gRPC address (host:port) for agent connection
	cmd := fmt.Sprintf(
		"curl -fsSL %s/agent/install.sh | bash -s -- --server %s --uuid %s --key %s",
		s.serverURL,
		s.grpcAddr,
		host.ID.String(),
		host.SecretKey,
	)

	return cmd, nil
}

// RegenerateSecretKey regenerates the secret key for a host
func (s *HostService) RegenerateSecretKey(ctx context.Context, id uuid.UUID) (string, error) {
	host, err := s.hostRepo.GetByID(ctx, id)
	if err != nil {
		return "", err
	}

	// Disconnect current agent if online
	if s.agentMgr.IsAgentOnline(host.ID.String()) {
		s.agentMgr.DisconnectAgent(host.ID.String())
	}

	// Generate new secret key
	newKey, err := s.generateSecretKey()
	if err != nil {
		return "", err
	}

	host.SecretKey = newKey // TODO: Encrypt
	if err := s.hostRepo.Update(ctx, host); err != nil {
		return "", err
	}

	return newKey, nil
}

// GetHostState retrieves the current state of a host
func (s *HostService) GetHostState(ctx context.Context, id uuid.UUID) (*models.HostState, error) {
	// Try cache first
	if state, ok := s.stateCollector.GetLatestState(id); ok {
		return state, nil
	}

	// Fallback to database
	return s.hostRepo.GetLatestState(ctx, id)
}

// GetHostStateHistory retrieves historical states for a host
func (s *HostService) GetHostStateHistory(ctx context.Context, id uuid.UUID, start, end string, interval string) ([]*models.HostState, error) {
	// Parse time strings (frontend sends UTC time)
	startTime, err := time.Parse(time.RFC3339, start)
	if err != nil {
		logrus.Warnf("Failed to parse start time: %v, using default", err)
		startTime = time.Now().Add(-24 * time.Hour) // Default to 24 hours ago
	} else {
		// Convert UTC to local time for database query (database stores local time)
		startTime = startTime.Local()
	}

	endTime, err := time.Parse(time.RFC3339, end)
	if err != nil {
		logrus.Warnf("Failed to parse end time: %v, using default", err)
		endTime = time.Now()
	} else {
		// Convert UTC to local time for database query (database stores local time)
		endTime = endTime.Local()
	}

	// Calculate interval in seconds based on the interval parameter
	var intervalSeconds int
	switch interval {
	case "1m":
		intervalSeconds = 60
	case "5m":
		intervalSeconds = 300
	case "15m":
		intervalSeconds = 900
	case "30m":
		intervalSeconds = 1800
	case "1h":
		intervalSeconds = 3600
	case "3h":
		intervalSeconds = 10800
	case "6h":
		intervalSeconds = 21600
	case "12h":
		intervalSeconds = 43200
	case "1d":
		intervalSeconds = 86400
	case "auto":
		// Auto-calculate interval based on time range
		duration := endTime.Sub(startTime)
		if duration.Hours() <= 1 {
			intervalSeconds = 60 // 1 minute for 1 hour range
		} else if duration.Hours() <= 6 {
			intervalSeconds = 300 // 5 minutes for 6 hours
		} else if duration.Hours() <= 12 {
			intervalSeconds = 300 // 5 minutes for 12 hours
		} else if duration.Hours() <= 24 {
			intervalSeconds = 600 // 10 minutes for 1 day
		} else if duration.Hours() <= 168 {
			intervalSeconds = 3600 // 1 hour for 1 week
		} else {
			intervalSeconds = 86400 // 1 day for longer ranges
		}
	default:
		// Try to parse as integer seconds
		if val, err := strconv.Atoi(interval); err == nil && val > 0 {
			intervalSeconds = val
		} else {
			// Default to auto for invalid values
			duration := endTime.Sub(startTime)
			if duration.Hours() <= 1 {
				intervalSeconds = 60
			} else if duration.Hours() <= 6 {
				intervalSeconds = 300
			} else if duration.Hours() <= 12 {
				intervalSeconds = 300
			} else if duration.Hours() <= 24 {
				intervalSeconds = 600
			} else {
				intervalSeconds = 3600
			}
		}
	}

	// Get states from repository with time range
	states, err := s.hostRepo.GetStatesByTimeRange(ctx, id, startTime, endTime, intervalSeconds)
	if err != nil {
		logrus.Errorf("Failed to get host states by time range: %v", err)
		// Fallback to latest states
		return s.hostRepo.GetLatestStates(ctx, id, 100)
	}

	return states, nil
}

// enrichHostWithRuntimeData adds online status and latest state to host
func (s *HostService) enrichHostWithRuntimeData(host *models.HostNode) {
	// Check online status
	uuidStr := host.ID.String()
	host.Online = s.agentMgr.IsAgentOnline(uuidStr)

	logrus.Debugf("[HostService] Enrich host %s (uuid=%s): online=%v",
		host.Name, uuidStr, host.Online)

	// Get connection info if online
	if host.Online {
		if conn := s.agentMgr.GetConnectionByHostID(host.ID); conn != nil {
			host.LastActive = &conn.LastSeen
		}
	}
}

// generateSecretKey generates a random secret key
func (s *HostService) generateSecretKey() (string, error) {
	// Generate 32 bytes (256 bits) of random data
	key := make([]byte, 32)
	if _, err := rand.Read(key); err != nil {
		return "", err
	}

	// Encode to base64 for easy transmission
	return base64.URLEncoding.EncodeToString(key), nil
}

// BatchUpdateDisplayIndex updates display indexes for multiple hosts
func (s *HostService) BatchUpdateDisplayIndex(ctx context.Context, updates map[uuid.UUID]int) error {
	for id, index := range updates {
		host, err := s.hostRepo.GetByID(ctx, id)
		if err != nil {
			return err
		}
		host.DisplayIndex = index
		if err := s.hostRepo.Update(ctx, host); err != nil {
			return err
		}
	}
	return nil
}

// GetOnlineHosts returns all currently online hosts
func (s *HostService) GetOnlineHosts(ctx context.Context) ([]*models.HostNode, error) {
	connections := s.agentMgr.GetActiveConnections()
	var hosts []*models.HostNode

	for _, conn := range connections {
		host, err := s.hostRepo.GetByID(ctx, conn.HostNodeID)
		if err != nil {
			continue
		}
		s.enrichHostWithRuntimeData(host)
		hosts = append(hosts, host)
	}

	return hosts, nil
}

// GetHostMetricsSummary returns a summary of key metrics for a host
func (s *HostService) GetHostMetricsSummary(ctx context.Context, id uuid.UUID) (map[string]interface{}, error) {
	state, err := s.GetHostState(ctx, id)
	if err != nil {
		return nil, err
	}

	summary := map[string]interface{}{
		"cpu_usage":    state.CPUUsage,
		"mem_usage":    state.MemUsage,
		"disk_usage":   state.DiskUsage,
		"uptime":       state.Uptime,
		"last_updated": state.Timestamp,
	}

	return summary, nil
}
