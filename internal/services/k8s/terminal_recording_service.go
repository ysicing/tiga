// Code generated by spec-kit:implement; DO NOT EDIT.
// This file was generated at 2025-10-29 22:15:00
// Source: .claude/specs/010-k8s-pod-009/tasks.md (task: T023)

package k8sservice

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"

	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
	"github.com/ysicing/tiga/pkg/kube"
	recording "github.com/ysicing/tiga/internal/services/recording"
)

// TerminalRecordingService handles K8s terminal recording operations
type TerminalRecordingService struct {
	recordingRepo repository.TerminalRecordingRepositoryInterface
}

// NewTerminalRecordingService creates a new terminal recording service
func NewTerminalRecordingService(recordingRepo repository.TerminalRecordingRepositoryInterface) *TerminalRecordingService {
	return &TerminalRecordingService{
		recordingRepo: recordingRepo,
	}
}

// StartNodeTerminalRecording starts recording for a K8s node terminal
func (s *TerminalRecordingService) StartNodeTerminalRecording(
	ctx context.Context,
	userID uuid.UUID,
	clusterID string,
	nodeName string,
	width int,
	height int,
) (*kube.K8sTerminalSession, *recording.AsciinemaRecorder, *models.TerminalRecording, error) {
	// Generate session ID
	sessionID := uuid.New()

	// Generate recording ID
	recordingID := uuid.New()

	// Create directory structure: ./recordings/k8s_node/YYYY-MM-DD/
	now := time.Now()
	dir := filepath.Join("recordings", "k8s_node", now.Format("2006-01-02"))
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create recording directory: %w", err)
	}

	// Recording file path
	recordingFilePath := filepath.Join(dir, fmt.Sprintf("%s.cast", recordingID.String()))

	// Create Asciinema recorder
	recorder, err := recording.NewAsciinemaRecorder(recordingFilePath, width, height, fmt.Sprintf("K8s Node Terminal - %s", nodeName))
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create recorder: %w", err)
	}

	// Prepare type metadata
	metadata := map[string]interface{}{
		"cluster_id": clusterID,
		"node_name":  nodeName,
	}
	metadataJSON, _ := json.Marshal(metadata)

	// Create database record
	recordingModel := &models.TerminalRecording{
		ID:              recordingID,
		SessionID:       sessionID,
		UserID:          userID,
		RecordingType:   models.RecordingTypeK8sNode,
		Title:           fmt.Sprintf("Node Terminal - %s", nodeName),
		Status:          "active",
		StartTime:       time.Now(),
		DurationSeconds: 0,
		TypeMetadata:    metadataJSON,
		FilePath:        recordingFilePath,
	}

	// Save to database
	if err := s.recordingRepo.Create(ctx, recordingModel); err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create recording record: %w", err)
	}

	// Create K8s terminal session
	session := &kube.K8sTerminalSession{
		SessionID:     sessionID,
		Type:          kube.K8sTerminalSessionTypeNode,
		ClusterID:     clusterID,
		NodeName:      nodeName,
		RecordingID:   &recordingID,
		RecordingState: "active",
		Recorder:      recorder,
		StartedAt:     time.Now(),
	}

	// Start recording with 2-hour timeout
	session.StartRecording(recorder, recordingID)

	logrus.Infof("Started node terminal recording: session=%s, node=%s, file=%s", sessionID, nodeName, recordingFilePath)

	return session, recorder, recordingModel, nil
}

// StartPodTerminalRecording starts recording for a K8s pod exec terminal
func (s *TerminalRecordingService) StartPodTerminalRecording(
	ctx context.Context,
	userID uuid.UUID,
	clusterID string,
	namespace string,
	podName string,
	containerName string,
	width int,
	height int,
) (*kube.K8sTerminalSession, *recording.AsciinemaRecorder, *models.TerminalRecording, error) {
	// Generate session ID
	sessionID := uuid.New()

	// Generate recording ID
	recordingID := uuid.New()

	// Create directory structure: ./recordings/k8s_pod/YYYY-MM-DD/
	now := time.Now()
	dir := filepath.Join("recordings", "k8s_pod", now.Format("2006-01-02"))
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create recording directory: %w", err)
	}

	// Recording file path
	recordingFilePath := filepath.Join(dir, fmt.Sprintf("%s.cast", recordingID.String()))

	// Create Asciinema recorder
	recorder, err := recording.NewAsciinemaRecorder(recordingFilePath, width, height, fmt.Sprintf("K8s Pod Terminal - %s/%s/%s", namespace, podName, containerName))
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create recorder: %w", err)
	}

	// Prepare type metadata
	metadata := map[string]interface{}{
		"cluster_id":     clusterID,
		"namespace":      namespace,
		"pod_name":       podName,
		"container_name": containerName,
	}
	metadataJSON, _ := json.Marshal(metadata)

	// Create database record
	recordingModel := &models.TerminalRecording{
		ID:              recordingID,
		SessionID:       sessionID,
		UserID:          userID,
		RecordingType:   models.RecordingTypeK8sPod,
		Title:           fmt.Sprintf("Pod Terminal - %s/%s/%s", namespace, podName, containerName),
		Status:          "active",
		StartTime:       time.Now(),
		DurationSeconds: 0,
		TypeMetadata:    metadataJSON,
		FilePath:        recordingFilePath,
	}

	// Save to database
	if err := s.recordingRepo.Create(ctx, recordingModel); err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create recording record: %w", err)
	}

	// Create K8s terminal session
	session := &kube.K8sTerminalSession{
		SessionID:      sessionID,
		Type:           kube.K8sTerminalSessionTypePod,
		ClusterID:      clusterID,
		Namespace:      namespace,
		PodName:        podName,
		ContainerName:  containerName,
		RecordingID:    &recordingID,
		RecordingState: "active",
		Recorder:       recorder,
		StartedAt:      time.Now(),
	}

	// Start recording with 2-hour timeout
	session.StartRecording(recorder, recordingID)

	logrus.Infof("Started pod terminal recording: session=%s, pod=%s/%s/%s, file=%s",
		sessionID, namespace, podName, containerName, recordingFilePath)

	return session, recorder, recordingModel, nil
}

// StopRecording stops an active recording and updates the database
func (s *TerminalRecordingService) StopRecording(ctx context.Context, recordingID uuid.UUID, reason string) error {
	// Get recording from database
	recording, err := s.recordingRepo.GetByID(ctx, recordingID)
	if err != nil {
		return fmt.Errorf("failed to get recording: %w", err)
	}

	// Update status and duration
	recording.Status = "stopped"
	recording.EndTime = time.Now()
	recording.DurationSeconds = int64(recording.EndTime.Sub(recording.StartTime).Seconds())

	// Update database
	if err := s.recordingRepo.Update(ctx, recording); err != nil {
		return fmt.Errorf("failed to update recording: %w", err)
	}

	logrus.Infof("Stopped terminal recording: id=%s, reason=%s, duration=%ds",
		recordingID, reason, recording.DurationSeconds)

	return nil
}

// GetRecording retrieves a recording by ID
func (s *TerminalRecordingService) GetRecording(ctx context.Context, recordingID uuid.UUID) (*models.TerminalRecording, error) {
	return s.recordingRepo.GetByID(ctx, recordingID)
}
