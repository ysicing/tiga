// Code generated by spec-kit:implement; DO NOT EDIT.
// This file was generated at 2025-10-29 22:15:00
// Source: .claude/specs/010-k8s-pod-009/tasks.md (task: T029-T030)

package k8sservice

import (
	"context"
	"os"
	"path/filepath"
	"time"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"

	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
)

// K8sCleanupService handles cleanup of K8s terminal recordings and audit logs
type K8sCleanupService struct {
	recordingRepo repository.TerminalRecordingRepositoryInterface
	auditRepo     repository.AuditEventRepositoryInterface
	retentionDays int
}

// NewK8sCleanupService creates a new K8s cleanup service
func NewK8sCleanupService(
	recordingRepo repository.TerminalRecordingRepositoryInterface,
	auditRepo repository.AuditEventRepositoryInterface,
	retentionDays int,
) *K8sCleanupService {
	return &K8sCleanupService{
		recordingRepo: recordingRepo,
		auditRepo:     auditRepo,
		retentionDays: retentionDays,
	}
}

// CleanupExpiredRecordings removes expired K8s terminal recordings
func (s *K8sCleanupService) CleanupExpiredRecordings(ctx context.Context) (int, error) {
	// Find recordings older than retention period
	retentionDate := time.Now().AddDate(0, 0, -s.retentionDays)
	recordings, err := s.recordingRepo.FindExpired(ctx, s.retentionDays, 1000)
	if err != nil {
		return 0, err
	}

	deletedCount := 0
	for _, recording := range recordings {
		// Skip if not K8s recording
		if recording.RecordingType != models.RecordingTypeK8sNode && recording.RecordingType != models.RecordingTypeK8sPod {
			continue
		}

		// Delete recording file
		if recording.FilePath != "" {
			if err := os.Remove(recording.FilePath); err != nil && !os.IsNotExist(err) {
				logrus.Errorf("Failed to delete recording file %s: %v", recording.FilePath, err)
				continue
			}
			logrus.Infof("Deleted recording file: %s", recording.FilePath)
		}

		// Delete database record
		if err := s.recordingRepo.Delete(ctx, recording.ID); err != nil {
			logrus.Errorf("Failed to delete recording %s from database: %v", recording.ID, err)
			continue
		}

		deletedCount++
	}

	logrus.Infof("Cleanup completed: deleted %d expired K8s recordings", deletedCount)
	return deletedCount, nil
}

// CleanupExpiredAuditEvents removes expired K8s audit events
func (s *K8sCleanupService) CleanupExpiredAuditEvents(ctx context.Context) (int, error) {
	// Find audit events older than retention period
	retentionDate := time.Now().AddDate(0, 0, -s.retentionDays)
	events, err := s.auditRepo.FindExpired(ctx, s.retentionDays, 1000)
	if err != nil {
		return 0, err
	}

	deletedCount := 0
	for _, event := range events {
		// Skip if not K8s event
		if event.Subsystem != models.SubsystemKubernetes {
			continue
		}

		// Delete database record
		if err := s.auditRepo.Delete(ctx, event.ID); err != nil {
			logrus.Errorf("Failed to delete audit event %s from database: %v", event.ID, err)
			continue
		}

		deletedCount++
	}

	logrus.Infof("Cleanup completed: deleted %d expired K8s audit events", deletedCount)
	return deletedCount, nil
}

// CleanupOldRecordingFiles removes orphaned recording files
func (s *K8sCleanupService) CleanupOldRecordingFiles(ctx context.Context) (int, error) {
	deletedCount := 0

	// Walk through recording directories
	baseDirs := []string{
		"recordings/k8s_node",
		"recordings/k8s_pod",
	}

	for _, baseDir := range baseDirs {
		if err := filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			// Only process .cast files
			if !info.IsDir() && filepath.Ext(path) == ".cast" {
				// Check if file is older than retention period
				if info.ModTime().Before(time.Now().AddDate(0, 0, -s.retentionDays)) {
					// Check if database record exists
					filename := filepath.Base(path)
					recordingID, err := uuid.Parse(filename[:36])
					if err != nil {
						// Delete orphaned file
						if err := os.Remove(path); err != nil && !os.IsNotExist(err) {
							logrus.Errorf("Failed to delete orphaned file %s: %v", path, err)
						} else {
							deletedCount++
							logrus.Infof("Deleted orphaned recording file: %s", path)
						}
					}
				}
			}

			return nil
		}); err != nil {
			logrus.Errorf("Failed to walk directory %s: %v", baseDir, err)
		}
	}

	logrus.Infof("Cleanup completed: deleted %d orphaned recording files", deletedCount)
	return deletedCount, nil
}

// RunCleanup runs all cleanup tasks
func (s *K8sCleanupService) RunCleanup(ctx context.Context) (CleanupResult, error) {
	result := CleanupResult{}

	recordingsDeleted, err := s.CleanupExpiredRecordings(ctx)
	if err != nil {
		logrus.Errorf("Failed to cleanup expired recordings: %v", err)
	} else {
		result.RecordingsDeleted = recordingsDeleted
	}

	auditDeleted, err := s.CleanupExpiredAuditEvents(ctx)
	if err != nil {
		logrus.Errorf("Failed to cleanup expired audit events: %v", err)
	} else {
		result.AuditEventsDeleted = auditDeleted
	}

	filesDeleted, err := s.CleanupOldRecordingFiles(ctx)
	if err != nil {
		logrus.Errorf("Failed to cleanup orphaned files: %v", err)
	} else {
		result.FilesDeleted = filesDeleted
	}

	logrus.Infof("All cleanup tasks completed: %+v", result)
	return result, nil
}

// CleanupResult holds the results of cleanup operations
type CleanupResult struct {
	RecordingsDeleted  int `json:"recordings_deleted"`
	AuditEventsDeleted int `json:"audit_events_deleted"`
	FilesDeleted       int `json:"files_deleted"`
}
