// Code generated by spec-kit:implement; DO NOT EDIT.
// This file was generated at 2025-10-29 22:15:00
// Source: .claude/specs/010-k8s-pod-009/tasks.md (task: T021)

package k8sservice

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
)

type MockAsyncAuditLogger struct {
	mock.Mock
}

func (m *MockAsyncAuditLogger) Log(ctx context.Context, event *models.AuditEvent) error {
	return m.Called(ctx, event).Error(0)
}

func (m *MockAsyncAuditLogger) Flush(ctx context.Context) error {
	return m.Called(ctx).Error(0)
}

type MockClusterRepository struct {
	mock.Mock
}

func (m *MockClusterRepository) Create(ctx context.Context, cluster *models.Cluster) error {
	return m.Called(ctx, cluster).Error(0)
}

func (m *MockClusterRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Cluster, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*models.Cluster), args.Error(1)
}

func (m *MockClusterRepository) Update(ctx context.Context, cluster *models.Cluster) error {
	return m.Called(ctx, cluster).Error(0)
}

func (m *MockClusterRepository) Delete(ctx context.Context, id uuid.UUID) error {
	return m.Called(ctx, id).Error(0)
}

func (m *MockClusterRepository) List(ctx context.Context) ([]*models.Cluster, error) {
	args := m.Called(ctx)
	return args.Get(0).([]*models.Cluster), args.Error(1)
}

func (m *MockClusterRepository) GetByName(ctx context.Context, name string) (*models.Cluster, error) {
	args := m.Called(ctx, name)
	return args.Get(0).(*models.Cluster), args.Error(1)
}

func (m *MockClusterRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status string, message *string) error {
	return m.Called(ctx, id, status, message).Error(0)
}

func TestK8sAuditService_LogResourceOperation(t *testing.T) {
	ctx := context.Background()
	mockLogger := new(MockAsyncAuditLogger)
	mockClusterRepo := new(MockClusterRepository)

	service := NewK8sAuditService(mockLogger, mockClusterRepo)

	log := &ResourceOperationLog{
		Action:         models.ActionCreateResource,
		ResourceType:   models.ResourceTypeDeployment,
		ClusterID:      "test-cluster",
		Namespace:      "default",
		ResourceName:   "test-deployment",
		Success:        true,
		RequestID:      uuid.New().String(),
	}

	expectedEvent := &models.AuditEvent{
		ID:           mock.MatchedBy(func(id string) bool { return len(id) > 0 }),
		Timestamp:    mock.MatchedBy(func(t int64) bool { return t > 0 }),
		Action:       models.ActionCreateResource,
		ResourceType: models.ResourceTypeDeployment,
		Subsystem:    models.SubsystemKubernetes,
		UserID:       "test-user",
		Username:     "test",
		ClientIP:     "127.0.0.1",
		ClusterID:    "test-cluster",
		Namespace:    "default",
		ResourceName: "test-deployment",
		Details:      mock.MatchedBy(func(d map[string]interface{}) bool { return true }),
	}

	mockLogger.On("Log", ctx, mock.MatchedBy(func(event *models.AuditEvent) bool {
		return event.Action == models.ActionCreateResource && event.Subsystem == models.SubsystemKubernetes
	})).Return(nil)

	err := service.LogResourceOperation(ctx, log)
	assert.NoError(t, err)

	mockLogger.AssertExpectations(t)
}

func TestK8sAuditService_LogTerminalAccess(t *testing.T) {
	ctx := context.Background()
	mockLogger := new(MockAsyncAuditLogger)
	mockClusterRepo := new(MockClusterRepository)

	service := NewK8sAuditService(mockLogger, mockClusterRepo)

	recordingID := uuid.New()
	log := &TerminalAccessLog{
		TerminalType: models.RecordingTypeK8sNode,
		ClusterID:    "test-cluster",
		NodeName:     "test-node",
		Namespace:    "default",
		PodName:      "test-pod",
		ContainerName: "test-container",
		RecordingID:  &recordingID,
		RequestID:    uuid.New().String(),
	}

	mockLogger.On("Log", ctx, mock.MatchedBy(func(event *models.AuditEvent) bool {
		return event.Action == models.ActionNodeTerminalAccess && event.Subsystem == models.SubsystemKubernetes
	})).Return(nil)

	err := service.LogTerminalAccess(ctx, log)
	assert.NoError(t, err)

	mockLogger.AssertExpectations(t)
}

func TestK8sAuditService_LogReadOperation(t *testing.T) {
	ctx := context.Background()
	mockLogger := new(MockAsyncAuditLogger)
	mockClusterRepo := new(MockClusterRepository)

	service := NewK8sAuditService(mockLogger, mockClusterRepo)

	log := &ReadOperationLog{
		Action:       models.ActionViewResource,
		ResourceType: models.ResourceTypePod,
		ClusterID:    "test-cluster",
		Namespace:    "default",
		ResourceName: "test-pod",
		RequestID:    uuid.New().String(),
	}

	mockLogger.On("Log", ctx, mock.MatchedBy(func(event *models.AuditEvent) bool {
		return event.Action == models.ActionViewResource && event.Subsystem == models.SubsystemKubernetes
	})).Return(nil)

	err := service.LogReadOperation(ctx, log)
	assert.NoError(t, err)

	mockLogger.AssertExpectations(t)
}

func TestResourceOperationLog_Validate(t *testing.T) {
	log := &ResourceOperationLog{
		Action:         models.ActionCreateResource,
		ResourceType:   models.ResourceTypeDeployment,
		ClusterID:      "test-cluster",
		Namespace:      "default",
		ResourceName:   "test-deployment",
		Success:        true,
		RequestID:      uuid.New().String(),
	}

	err := log.Validate()
	assert.NoError(t, err)

	// Test with missing required fields
	invalidLog := &ResourceOperationLog{
		Action:         models.ActionCreateResource,
		ResourceType:   models.ResourceTypeDeployment,
		ClusterID:      "",
		Namespace:      "",
		ResourceName:   "",
		Success:        false,
		RequestID:      uuid.New().String(),
	}

	err = invalidLog.Validate()
	assert.Error(t, err)
}

func TestTerminalAccessLog_Validate(t *testing.T) {
	recordingID := uuid.New()
	log := &TerminalAccessLog{
		TerminalType:  models.RecordingTypeK8sNode,
		ClusterID:     "test-cluster",
		NodeName:      "test-node",
		Namespace:     "default",
		PodName:       "test-pod",
		ContainerName: "test-container",
		RecordingID:   &recordingID,
		RequestID:     uuid.New().String(),
	}

	err := log.Validate()
	assert.NoError(t, err)

	// Test with missing required fields
	invalidLog := &TerminalAccessLog{
		TerminalType:  models.RecordingTypeK8sNode,
		ClusterID:     "",
		NodeName:      "",
		Namespace:     "",
		PodName:       "",
		ContainerName: "",
		RecordingID:   nil,
		RequestID:     uuid.New().String(),
	}

	err = invalidLog.Validate()
	assert.Error(t, err)
}

func TestReadOperationLog_Validate(t *testing.T) {
	log := &ReadOperationLog{
		Action:       models.ActionViewResource,
		ResourceType: models.ResourceTypePod,
		ClusterID:    "test-cluster",
		Namespace:    "default",
		ResourceName: "test-pod",
		RequestID:    uuid.New().String(),
	}

	err := log.Validate()
	assert.NoError(t, err)
}
