// Code generated by spec-kit:implement; DO NOT EDIT.
// This file was generated at 2025-10-29 22:15:00
// Source: .claude/specs/010-k8s-pod-009/tasks.md (task: T024-T025)

package handlers

import (
	"context"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/sirupsen/logrus"

	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
	recording "github.com/ysicing/tiga/internal/services/recording"
)

type K8sRecordingHandler struct {
	recordingRepo     repository.TerminalRecordingRepositoryInterface
	recordingService  recording.ManagerService
}

func NewK8sRecordingHandler(
	recordingRepo repository.TerminalRecordingRepositoryInterface,
	recordingService recording.ManagerService,
) *K8sRecordingHandler {
	return &K8sRecordingHandler{
		recordingRepo:    recordingRepo,
		recordingService: recordingService,
	}
}

// ListK8sRecordings lists K8s terminal recordings with filtering
func (h *K8sRecordingHandler) ListK8sRecordings(c *gin.Context) {
	ctx := c.Request.Context()

	// Parse query parameters
	userID := c.Query("user_id")
	clusterID := c.Query("cluster_id")
	nodeName := c.Query("node_name")
	namespace := c.Query("namespace")
	podName := c.Query("pod_name")
	container := c.Query("container")

	// Parse pagination
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))

	// Build filter
	filter := &repository.TerminalRecordingFilter{
		RecordingTypes: []string{models.RecordingTypeK8sNode, models.RecordingTypeK8sPod},
	}

	if userID != "" {
		if uid, err := uuid.Parse(userID); err == nil {
			filter.UserID = &uid
		}
	}

	// Build type metadata filter
	typeMetadata := make(map[string]interface{})
	if clusterID != "" {
		typeMetadata["cluster_id"] = clusterID
	}
	if nodeName != "" {
		typeMetadata["node_name"] = nodeName
	}
	if namespace != "" {
		typeMetadata["namespace"] = namespace
	}
	if podName != "" {
		typeMetadata["pod_name"] = podName
	}
	if container != "" {
		typeMetadata["container_name"] = container
	}

	if len(typeMetadata) > 0 {
		filter.TypeMetadata = typeMetadata
	}

	recordings, total, err := h.recordingRepo.List(ctx, filter)
	if err != nil {
		logrus.Errorf("Failed to list K8s recordings: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list recordings"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data": recordings,
		"pagination": gin.H{
			"page":       page,
			"page_size":  pageSize,
			"total":      total,
			"total_page": (total + int64(pageSize) - 1) / int64(pageSize),
		},
	})
}

// GetK8sRecordingDetail gets detailed information about a K8s terminal recording
func (h *K8sRecordingHandler) GetK8sRecordingDetail(c *gin.Context) {
	ctx := c.Request.Context()
	recordingID := c.Param("id")

	if recordingID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Recording ID is required"})
		return
	}

	uid, err := uuid.Parse(recordingID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid recording ID"})
		return
	}

	recording, err := h.recordingRepo.GetByID(ctx, uid)
	if err != nil {
		logrus.Errorf("Failed to get recording %s: %v", recordingID, err)
		c.JSON(http.StatusNotFound, gin.H{"error": "Recording not found"})
		return
	}

	// Validate it's a K8s recording
	if recording.RecordingType != models.RecordingTypeK8sNode && recording.RecordingType != models.RecordingTypeK8sPod {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Not a K8s terminal recording"})
		return
	}

	c.JSON(http.StatusOK, recording)
}

// PlayK8sRecording streams a K8s terminal recording
func (h *K8sRecordingHandler) PlayK8sRecording(c *gin.Context) {
	ctx := c.Request.Context()
	recordingID := c.Param("id")

	uid, err := uuid.Parse(recordingID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid recording ID"})
		return
	}

	recording, err := h.recordingRepo.GetByID(ctx, uid)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Recording not found"})
		return
	}

	// Validate it's a K8s recording
	if recording.RecordingType != models.RecordingTypeK8sNode && recording.RecordingType != models.RecordingTypeK8sPod {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Not a K8s terminal recording"})
		return
	}

	// Stream the recording file
	c.Header("Content-Type", "application/json")
	c.Header("Content-Disposition", "inline; filename=\""+recordingID+".cast\"")
	c.File(recording.FilePath)
}
