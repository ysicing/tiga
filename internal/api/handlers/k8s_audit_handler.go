// Code generated by spec-kit:implement; DO NOT EDIT.
// This file was generated at 2025-10-29 22:15:00
// Source: .claude/specs/010-k8s-pod-009/tasks.md (task: T026-T028)

package handlers

import (
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/sirupsen/logrus"

	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
)

type K8sAuditHandler struct {
	auditEventRepo repository.AuditEventRepositoryInterface
}

func NewK8sAuditHandler(auditEventRepo repository.AuditEventRepositoryInterface) *K8sAuditHandler {
	return &K8sAuditHandler{
		auditEventRepo: auditEventRepo,
	}
}

// ListK8sAuditEvents lists K8s audit events with filtering
func (h *K8sAuditHandler) ListK8sAuditEvents(c *gin.Context) {
	ctx := c.Request.Context()

	// Parse query parameters
	userID := c.Query("user_id")
	clusterID := c.Query("cluster_id")
	namespace := c.Query("namespace")
	action := c.Query("action")
	resourceType := c.Query("resource_type")

	// Parse time range
	startTime := c.Query("start_time")
	endTime := c.Query("end_time")

	// Parse pagination
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))

	// Build filter
	filter := &repository.AuditEventFilter{
		Subsystems: []models.Subsystem{models.SubsystemKubernetes},
	}

	if userID != "" {
		if uid, err := uuid.Parse(userID); err == nil {
			filter.UserID = &uid
		}
	}

	if clusterID != "" {
		filter.ClusterID = &clusterID
	}

	if namespace != "" {
		filter.Namespace = &namespace
	}

	if action != "" {
		filter.Actions = []models.Action{models.Action(action)}
	}

	if resourceType != "" {
		filter.ResourceTypes = []models.ResourceType{models.ResourceType(resourceType)}
	}

	// Parse time range
	if startTime != "" {
		if t, err := time.Parse(time.RFC3339, startTime); err == nil {
			filter.StartTime = &t
		}
	}

	if endTime != "" {
		if t, err := time.Parse(time.RFC3339, endTime); err == nil {
			filter.EndTime = &t
		}
	}

	events, total, err := h.auditEventRepo.List(ctx, filter)
	if err != nil {
		logrus.Errorf("Failed to list K8s audit events: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list audit events"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data": events,
		"pagination": gin.H{
			"page":       page,
			"page_size":  pageSize,
			"total":      total,
			"total_page": (total + int64(pageSize) - 1) / int64(pageSize),
		},
	})
}

// GetK8sAuditEventDetail gets detailed information about a K8s audit event
func (h *K8sAuditHandler) GetK8sAuditEventDetail(c *gin.Context) {
	ctx := c.Request.Context()
	eventID := c.Param("id")

	if eventID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Event ID is required"})
		return
	}

	uid, err := uuid.Parse(eventID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid event ID"})
		return
	}

	event, err := h.auditEventRepo.GetByID(ctx, uid)
	if err != nil {
		logrus.Errorf("Failed to get audit event %s: %v", eventID, err)
		c.JSON(http.StatusNotFound, gin.H{"error": "Audit event not found"})
		return
	}

	// Validate it's a K8s audit event
	if event.Subsystem != models.SubsystemKubernetes {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Not a K8s audit event"})
		return
	}

	c.JSON(http.StatusOK, event)
}

// GetK8sAuditStats gets statistics for K8s audit events
func (h *K8sAuditHandler) GetK8sAuditStats(c *gin.Context) {
	ctx := c.Request.Context()

	startTime := c.Query("start_time")
	endTime := c.Query("end_time")

	filter := &repository.AuditEventFilter{
		Subsystems: []models.Subsystem{models.SubsystemKubernetes},
	}

	// Parse time range
	if startTime != "" {
		if t, err := time.Parse(time.RFC3339, startTime); err == nil {
			filter.StartTime = &t
		}
	}

	if endTime != "" {
		if t, err := time.Parse(time.RFC3339, endTime); err == nil {
			filter.EndTime = &t
		}
	}

	stats, err := h.auditEventRepo.GetStatistics(ctx, filter)
	if err != nil {
		logrus.Errorf("Failed to get K8s audit stats: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get audit statistics"})
		return
	}

	c.JSON(http.StatusOK, stats)
}
