// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"context"
	"embed"
	"fmt"
	"time"

	"github.com/google/wire"
	"github.com/ysicing/tiga/internal/config"
	"github.com/ysicing/tiga/internal/db"
	"github.com/ysicing/tiga/internal/repository"
	"github.com/ysicing/tiga/internal/repository/scheduler"
	"github.com/ysicing/tiga/internal/services"
	"github.com/ysicing/tiga/internal/services/alert"
	"github.com/ysicing/tiga/internal/services/auth"
	"github.com/ysicing/tiga/internal/services/host"
	"github.com/ysicing/tiga/internal/services/k8s"
	"github.com/ysicing/tiga/internal/services/managers"
	"github.com/ysicing/tiga/internal/services/monitor"
	"github.com/ysicing/tiga/internal/services/notification"
	"github.com/ysicing/tiga/internal/services/prometheus"
	scheduler2 "github.com/ysicing/tiga/internal/services/scheduler"
	"github.com/ysicing/tiga/pkg/kube"
	"gorm.io/gorm"
)

// Injectors from wire.go:

// InitializeApplication is the main wire injector function
func InitializeApplication(ctx context.Context, cfg *config.Config, configPath string, installMode bool, staticFS embed.FS) (*Application, error) {
	databaseConfig := provideDatabaseConfig(cfg)
	database, err := db.NewDatabase(databaseConfig)
	if err != nil {
		return nil, err
	}
	gormDB := provideGormDB(database)
	taskRepository := scheduler.NewTaskRepository(gormDB)
	executionRepository := scheduler.NewExecutionRepository(gormDB)
	schedulerScheduler := scheduler2.NewScheduler(taskRepository, executionRepository)
	managerFactory := managers.NewManagerFactory()
	instanceRepository := repository.NewInstanceRepository(gormDB)
	metricsRepository := repository.NewMetricsRepository(gormDB)
	auditLogRepository := repository.NewAuditLogRepository(gormDB)
	managerCoordinator := managers.NewManagerCoordinator(managerFactory, instanceRepository, metricsRepository, auditLogRepository)
	jwtManager, err := provideJWTManager(cfg)
	if err != nil {
		return nil, err
	}
	hostRepository := repository.NewHostRepository(gormDB)
	auditEventRepository := repository.NewAuditEventRepository(gormDB)
	hostMonitoringComponents := provideHostMonitoringComponents(hostRepository, gormDB, auditEventRepository)
	stateCollector := provideStateCollector(hostMonitoringComponents)
	agentManager := provideAgentManager(hostMonitoringComponents)
	terminalManager := host.NewTerminalManager()
	hostService := provideHostService(hostRepository, agentManager, stateCollector, cfg)
	serviceRepository := repository.NewServiceRepository(gormDB)
	monitorAlertRepository := repository.NewMonitorAlertRepository(gormDB)
	alertEngine := provideAlertEngine(monitorAlertRepository, hostRepository, serviceRepository)
	serviceProbeScheduler := provideServiceProbeScheduler(serviceRepository, alertEngine)
	clusterRepository := repository.NewClusterRepository(gormDB)
	resourceHistoryRepository := repository.NewResourceHistoryRepository(gormDB)
	k8sService := services.NewK8sService(clusterRepository, resourceHistoryRepository)
	clientCache := provideClientCache()
	autoDiscoveryService := prometheus.NewAutoDiscoveryService(clusterRepository, clientCache, cfg)
	clusterHealthService := k8s.NewClusterHealthService(clusterRepository, clientCache, autoDiscoveryService)
	cacheService := k8s.NewCacheService()
	relationsService := k8s.NewRelationsService()
	searchService := provideSearchService(cacheService)
	application, err := newWireApplication(cfg, configPath, installMode, staticFS, database, schedulerScheduler, managerCoordinator, jwtManager, hostRepository, stateCollector, agentManager, terminalManager, hostService, serviceProbeScheduler, k8sService, clusterHealthService, autoDiscoveryService, cacheService, relationsService, searchService)
	if err != nil {
		return nil, err
	}
	return application, nil
}

// wire.go:

// DatabaseSet provides database-related dependencies
var DatabaseSet = wire.NewSet(
	provideDatabaseConfig, db.NewDatabase, provideGormDB,
)

// RepositorySet provides all repository interfaces
var RepositorySet = wire.NewSet(repository.NewUserRepository, wire.Bind(new(repository.UserRepositoryInterface), new(*repository.UserRepository)), repository.NewInstanceRepository, wire.Bind(new(repository.InstanceRepositoryInterface), new(*repository.InstanceRepository)), repository.NewMetricsRepository, wire.Bind(new(repository.MetricsRepositoryInterface), new(*repository.MetricsRepository)), repository.NewAlertRepository, wire.Bind(new(repository.AlertRepositoryInterface), new(*repository.AlertRepository)), repository.NewAuditLogRepository, wire.Bind(new(repository.AuditLogRepositoryInterface), new(*repository.AuditLogRepository)), repository.NewClusterRepository, wire.Bind(new(repository.ClusterRepositoryInterface), new(*repository.ClusterRepository)), repository.NewResourceHistoryRepository, wire.Bind(new(repository.ResourceHistoryRepositoryInterface), new(*repository.ResourceHistoryRepository)), scheduler.NewExecutionRepository, scheduler.NewTaskRepository, repository.NewAuditEventRepository, repository.NewHostRepository, repository.NewServiceRepository, repository.NewMonitorAlertRepository)

// ServiceSet provides core services
var ServiceSet = wire.NewSet(services.NewK8sService, notification.NewNotificationService, managers.NewManagerFactory, managers.NewManagerCoordinator, provideAlertProcessor,
	provideAlertEngine,
)

// HostMonitoringComponents aggregates host monitoring services to handle circular dependencies
type HostMonitoringComponents struct {
	StateCollector *host.StateCollector
	AgentManager   *host.AgentManager
}

// HostServiceSet provides host monitoring services
var HostServiceSet = wire.NewSet(
	provideHostMonitoringComponents, host.NewTerminalManager, provideHostService,
	provideStateCollector,
	provideAgentManager,
)

// MonitoringServiceSet provides monitoring services
var MonitoringServiceSet = wire.NewSet(
	provideServiceProbeScheduler,
)

// K8sServiceSet provides K8s cluster health and Prometheus discovery services
var K8sServiceSet = wire.NewSet(
	provideClientCache, prometheus.NewAutoDiscoveryService, k8s.NewClusterHealthService, k8s.NewCacheService, k8s.NewRelationsService, provideSearchService,
)

// AuthSet provides authentication services
var AuthSet = wire.NewSet(
	provideJWTManager,
)

// SchedulerSet provides scheduler
// T027: Updated to include ExecutionRepository dependency
var SchedulerSet = wire.NewSet(scheduler2.NewScheduler)

func provideDatabaseConfig(cfg *config.Config) *config.DatabaseConfig {
	return &cfg.Database
}

func provideGormDB(database *db.Database) *gorm.DB {
	return database.DB
}

func provideAlertProcessor(
	alertRepo *repository.AlertRepository,
	metricsRepo *repository.MetricsRepository,
	notificationSvc *notification.NotificationService,
	coordinator *managers.ManagerCoordinator,
) *alert.AlertProcessor {
	return alert.NewAlertProcessor(alertRepo, metricsRepo, notificationSvc, coordinator)
}

func provideAlertEngine(
	monitorAlertRepo repository.MonitorAlertRepository,
	hostRepo repository.HostRepository,
	serviceRepo repository.ServiceRepository,
) *alert.AlertEngine {
	return alert.NewAlertEngine(monitorAlertRepo, hostRepo, serviceRepo)
}

// Handle StateCollector and AgentManager circular dependency
// T038: Added AuditEventRepository for host audit logging
func provideHostMonitoringComponents(
	hostRepo repository.HostRepository, db2 *gorm.DB,
	auditEventRepo repository.AuditEventRepository,
) *HostMonitoringComponents {

	stateCollector := host.NewStateCollector(hostRepo)

	auditLogger := host.NewAuditLogger(auditEventRepo, nil)

	agentManager := host.NewAgentManager(hostRepo, stateCollector, db2, auditLogger)

	stateCollector.SetAgentManager(agentManager)

	return &HostMonitoringComponents{
		StateCollector: stateCollector,
		AgentManager:   agentManager,
	}
}

// Extract StateCollector from HostMonitoringComponents
func provideStateCollector(components *HostMonitoringComponents) *host.StateCollector {
	return components.StateCollector
}

// Extract AgentManager from HostMonitoringComponents
func provideAgentManager(components *HostMonitoringComponents) *host.AgentManager {
	return components.AgentManager
}

// T038: Provide AuditLogger for host subsystem (used by handlers)
func provideHostAuditLogger(auditEventRepo repository.AuditEventRepository) *host.AuditLogger {
	return host.NewAuditLogger(auditEventRepo, nil)
}

func provideHostService(
	hostRepo repository.HostRepository,
	agentManager *host.AgentManager,
	stateCollector *host.StateCollector,
	cfg *config.Config,
) *host.HostService {
	serverURL := fmt.Sprintf("http://localhost:%d", cfg.Server.Port)
	grpcPort := cfg.Server.GRPCPort
	if grpcPort == 0 {
		grpcPort = 12307
	}
	grpcAddr := fmt.Sprintf("localhost:%d", grpcPort)

	return host.NewHostService(hostRepo, agentManager, stateCollector, serverURL, grpcAddr)
}

func provideServiceProbeScheduler(
	serviceRepo repository.ServiceRepository,
	alertEngine *alert.AlertEngine,
) *monitor.ServiceProbeScheduler {
	return monitor.NewServiceProbeScheduler(serviceRepo, alertEngine)
}

func provideClientCache() *kube.ClientCache {
	return kube.NewClientCache()
}

func provideSearchService(cacheService *k8s.CacheService) *k8s.SearchService {
	return k8s.NewSearchService(cacheService)
}

func provideJWTManager(cfg *config.Config) (*auth.JWTManager, error) {
	jwtSecret := cfg.JWT.Secret
	if jwtSecret == "" {
		return nil, fmt.Errorf("JWT secret is not configured")
	}
	if len(jwtSecret) < 32 {
		return nil, fmt.Errorf("JWT secret must be at least 32 characters")
	}

	return auth.NewJWTManager(
		jwtSecret,
		24*time.Hour,
		7*24*time.Hour,
	), nil
}

// newWireApplication is the internal constructor used by wire
func newWireApplication(
	cfg *config.Config,
	configPath string,
	installMode bool,
	staticFS embed.FS,
	database *db.Database, scheduler3 *scheduler2.Scheduler,
	coordinator *managers.ManagerCoordinator,
	jwtManager *auth.JWTManager,
	hostRepo repository.HostRepository,
	stateCollector *host.StateCollector,
	agentManager *host.AgentManager,
	terminalManager *host.TerminalManager,
	hostService *host.HostService,
	probeScheduler *monitor.ServiceProbeScheduler,
	k8sService *services.K8sService,
	clusterHealthService *k8s.ClusterHealthService,
	prometheusDiscovery *prometheus.AutoDiscoveryService,

	cacheService *k8s.CacheService,
	relationsService *k8s.RelationsService,
	searchService *k8s.SearchService,
) (*Application, error) {
	app := &Application{
		config:               cfg,
		configPath:           configPath,
		db:                   database,
		scheduler:            scheduler3,
		coordinator:          coordinator,
		jwtManager:           jwtManager,
		installMode:          installMode,
		staticFS:             staticFS,
		hostRepo:             hostRepo,
		stateCollector:       stateCollector,
		agentManager:         agentManager,
		terminalManager:      terminalManager,
		hostService:          hostService,
		probeScheduler:       probeScheduler,
		k8sService:           k8sService,
		clusterHealthService: clusterHealthService,
		prometheusDiscovery:  prometheusDiscovery,

		cacheService:     cacheService,
		relationsService: relationsService,
		searchService:    searchService,
	}

	return app, nil
}
