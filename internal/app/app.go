package app

import (
	"context"
	"embed"
	"errors"
	"fmt"
	"io/fs"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc"
	"gorm.io/gorm"

	"github.com/ysicing/tiga/internal/api"
	"github.com/ysicing/tiga/internal/api/middleware"
	"github.com/ysicing/tiga/internal/config"
	"github.com/ysicing/tiga/internal/db"
	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
	"github.com/ysicing/tiga/internal/services"
	"github.com/ysicing/tiga/internal/services/alert"
	"github.com/ysicing/tiga/internal/services/auth"
	dockerservices "github.com/ysicing/tiga/internal/services/docker"
	"github.com/ysicing/tiga/internal/services/host"
	"github.com/ysicing/tiga/internal/services/k8s"
	"github.com/ysicing/tiga/internal/services/managers"
	"github.com/ysicing/tiga/internal/services/monitor"
	"github.com/ysicing/tiga/internal/services/notification"
	"github.com/ysicing/tiga/internal/services/prometheus"
	"github.com/ysicing/tiga/internal/services/scheduler"
	"github.com/ysicing/tiga/pkg/crypto"
	"github.com/ysicing/tiga/proto"

	installhandlers "github.com/ysicing/tiga/internal/install/handlers"
)

// Application represents the main application
type Application struct {
	config         *config.Config
	configPath     string
	db             *db.Database
	router         *middleware.RouterConfig
	scheduler      *scheduler.Scheduler
	coordinator    *managers.ManagerCoordinator
	jwtManager     *auth.JWTManager
	httpServer     *http.Server
	grpcServer     *grpc.Server
	installMode    bool
	installChannel chan struct{}
	staticFS       embed.FS

	// Host monitoring services (shared between gRPC and HTTP)
	hostRepo        repository.HostRepository
	stateCollector  *host.StateCollector
	agentManager    *host.AgentManager
	terminalManager *host.TerminalManager
	hostService     *host.HostService

	// Service monitoring
	probeScheduler *monitor.ServiceProbeScheduler

	// K8s service (for kubeconfig import and cluster management)
	k8sService *services.K8sService

	// K8s cluster health and Prometheus discovery
	clusterHealthService *k8s.ClusterHealthService
	prometheusDiscovery  *prometheus.AutoDiscoveryService

	// Phase 3 services: resource relations, caching, and search
	cacheService     *k8s.CacheService
	relationsService *k8s.RelationsService
	searchService    *k8s.SearchService
}

// NewApplication creates a new application instance using Wire dependency injection
// This function is now a wrapper around InitializeApplication (generated by wire)
func NewApplication(cfg *config.Config, configPath string, installMode bool, staticFS embed.FS) (*Application, error) {
	// In installation mode, create minimal app
	if installMode {
		app := &Application{
			config:      cfg,
			configPath:  configPath,
			installMode: installMode,
			scheduler:   scheduler.NewScheduler(nil, nil), // nil TaskRepository and ExecutionRepository in install mode
			staticFS:    staticFS,
		}
		return app, nil
	}

	// Use wire to initialize all dependencies
	app, err := InitializeApplication(context.Background(), cfg, configPath, installMode, staticFS)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize application with wire: %w", err)
	}

	// Perform database migration and seeding
	if err := app.db.AutoMigrate(); err != nil {
		return nil, fmt.Errorf("failed to migrate database: %w", err)
	}

	if err := app.db.SeedDefaultData(); err != nil {
		logrus.Warnf("Failed to seed default data: %v", err)
	}

	return app, nil
}

// Initialize initializes the application components
// Wire has already created all dependencies in NewApplication
// This method handles runtime initialization (encryption keys, servers, etc.)
func (a *Application) Initialize(ctx context.Context) error {
	// In installation mode, skip full initialization
	if a.installMode {
		logrus.Info("Running in installation mode - skipping full initialization")
		return a.initializeInstallMode(ctx)
	}

	logrus.Info("Initializing application runtime components...")

	// Initialize global DB for backward compatibility with legacy packages
	models.DB = a.db.DB
	models.InitRepositories(a.db.DB)

	// Ensure and initialize encryption keys
	appEncryptionKey, err := a.ensureApplicationEncryptionKey(ctx)
	if err != nil {
		return err
	}

	// Set encryption key for models.SecretString
	models.SetEncryptionKey(appEncryptionKey)

	credentialKey, err := a.ensureDatabaseCredentialKey(ctx)
	if err != nil {
		return err
	}

	// Initialize default encryption service for database credential storage
	if err := crypto.InitDefaultServiceFromBase64(credentialKey); err != nil {
		if len(credentialKey) == 32 {
			if errInit := crypto.InitDefaultService([]byte(credentialKey)); errInit != nil {
				return fmt.Errorf("failed to initialize database credential encryption: %w", errInit)
			}
			logrus.Warn("DB credential key is not base64 encoded; falling back to raw 32-byte key")
		} else {
			return fmt.Errorf("failed to initialize database credential encryption: %w", err)
		}
	}

	// Try to import clusters from default kubeconfig
	kubeconfigPath := os.Getenv("KUBECONFIG")
	if kubeconfigPath == "" {
		kubeconfigPath = os.Getenv("HOME") + "/.kube/config"
	}
	if _, err := os.Stat(kubeconfigPath); err == nil {
		// Use wire-injected k8sService for kubeconfig import
		if err := a.k8sService.ImportClustersFromKubeconfig(ctx, kubeconfigPath); err != nil {
			logrus.Warnf("Failed to import clusters from kubeconfig: %v", err)
		}
	}

	// Start cluster health check service (T062)
	if a.clusterHealthService != nil {
		logrus.Info("Starting cluster health check service...")
		a.clusterHealthService.Start(ctx)
	}

	// Start monitoring (coordinator was created by wire)
	a.coordinator.StartMonitoring(ctx)

	logrus.Info("Application runtime components initialized successfully")

	// Initialize JWT auth middleware (jwtManager was created by wire)
	middleware.InitJWTAuthMiddleware(a.jwtManager, a.db.DB)

	// Setup HTTP router
	routerConfig := &middleware.RouterConfig{
		DebugMode:     a.config.Server.Debug,
		EnableSwagger: true,
	}

	router := middleware.NewRouter(routerConfig)

	// Register all API handlers
	api.SetupRoutes(
		router,
		a.db.DB,
		a.configPath,
		a.jwtManager,
		a.config.JWT.Secret,
		a.config.DatabaseManagement,
		a.hostService,
		a.stateCollector,
		a.terminalManager,
		a.probeScheduler,
		a.config,
	)

	// Serve static files from embedded filesystem
	a.setupStaticFiles(router)

	a.httpServer = &http.Server{
		Addr:         fmt.Sprintf(":%d", a.config.Server.Port),
		Handler:      router,
		ReadTimeout:  time.Duration(a.config.Server.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(a.config.Server.WriteTimeout) * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	// Initialize gRPC server for Agent communication
	grpcService := host.NewGRPCServer(a.agentManager, a.terminalManager, a.probeScheduler)

	a.grpcServer = grpc.NewServer()
	proto.RegisterHostMonitorServer(a.grpcServer, grpcService)

	logrus.Info("gRPC server initialized for Agent monitoring")

	// T027: Register scheduled tasks to the enhanced scheduler
	if err := a.registerScheduledTasks(ctx); err != nil {
		return fmt.Errorf("failed to register scheduled tasks: %w", err)
	}

	return nil
}

// initializeInstallMode initializes minimal components for installation mode
func (a *Application) initializeInstallMode(_ context.Context) error {
	logrus.Info("Initializing installation mode...")

	// Create channel for installation completion signal first
	a.installChannel = make(chan struct{})

	// Setup HTTP router in installation mode
	routerConfig := &middleware.RouterConfig{
		DebugMode:     a.config.Server.Debug,
		EnableSwagger: false, // Disable Swagger in installation mode
	}

	router := middleware.NewRouter(routerConfig)

	// Register install handler with completion channel
	installHandler := installhandlers.NewInstallHandler(a.configPath, a.installChannel)
	apiGroup := router.Group("/api")
	installHandler.RegisterRoutes(apiGroup)

	// Serve static files from embedded filesystem
	a.setupStaticFiles(router)

	a.httpServer = &http.Server{
		Addr:         fmt.Sprintf(":%d", a.config.Server.Port),
		Handler:      router,
		ReadTimeout:  time.Duration(a.config.Server.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(a.config.Server.WriteTimeout) * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	logrus.Info("Installation mode initialized successfully")
	return nil
}

// Run runs the application
func (a *Application) Run(ctx context.Context) error {
	// Start gRPC server for Agents (if not in install mode)
	if !a.installMode && a.grpcServer != nil {
		grpcPort := a.config.Server.GRPCPort
		if grpcPort == 0 {
			grpcPort = 12307
		}
		go func() {
			listener, err := net.Listen("tcp", fmt.Sprintf(":%d", grpcPort))
			if err != nil {
				logrus.Fatalf("Failed to listen on gRPC port %d: %v", grpcPort, err)
			}
			logrus.Infof("Starting gRPC server on port %d", grpcPort)
			if err := a.grpcServer.Serve(listener); err != nil {
				logrus.Fatalf("gRPC server failed: %v", err)
			}
		}()
	}

	// Start HTTP server
	go func() {
		logrus.Infof("Starting HTTP server on %s", a.httpServer.Addr)
		if err := a.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logrus.Fatalf("HTTP server failed: %v", err)
		}
	}()

	// In installation mode, wait for completion or interrupt
	if a.installMode {
		quit := make(chan os.Signal, 1)
		signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

		var installCompleted bool
		select {
		case <-a.installChannel:
			logrus.Info("Installation completed successfully")
			installCompleted = true
		case <-quit:
			logrus.Info("Installation interrupted by user")
		}

		// Shutdown HTTP server
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		if err := a.httpServer.Shutdown(shutdownCtx); err != nil {
			logrus.Errorf("Server forced to shutdown: %v", err)
		}

		// Auto-restart if installation completed successfully
		if installCompleted {
			logrus.Info("Restarting application in normal mode...")
			time.Sleep(1 * time.Second) // Brief pause for cleanup
			if err := a.restartProcess(); err != nil {
				logrus.Errorf("Failed to restart process: %v", err)
				logrus.Info("Please manually restart the application to enter normal mode.")
				return err
			}
		}

		logrus.Info("Installation server exited")
		return nil
	}

	// Normal mode: start services
	go a.scheduler.Start(ctx)

	// Start service probe scheduler (includes ServiceSentinel)
	if a.probeScheduler != nil {
		go a.probeScheduler.Start()
		logrus.Info("Service probe scheduler started")
	}

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logrus.Info("Shutting down server...")
	totalStart := time.Now()

	// Shutdown gRPC server
	if a.grpcServer != nil {
		stepStart := time.Now()
		a.grpcServer.GracefulStop()
		logrus.Infof("[1/7] ✓ gRPC server stopped (%v)", time.Since(stepStart))
	}

	// Shutdown HTTP server
	stepStart := time.Now()
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := a.httpServer.Shutdown(shutdownCtx); err != nil {
		logrus.Warnf("[2/7] ✗ HTTP server forced shutdown (%v): %v", time.Since(stepStart), err)
	} else {
		logrus.Infof("[2/7] ✓ HTTP server stopped (%v)", time.Since(stepStart))
	}

	// Stop scheduler
	stepStart = time.Now()
	a.scheduler.Stop()
	logrus.Infof("[3/7] ✓ Scheduler stopped (%v)", time.Since(stepStart))

	// Stop service probe scheduler (includes ServiceSentinel)
	if a.probeScheduler != nil {
		stepStart = time.Now()
		a.probeScheduler.Stop()
		logrus.Infof("[4/7] ✓ Service probe scheduler stopped (%v)", time.Since(stepStart))
	}

	// Stop monitoring
	stepStart = time.Now()
	a.coordinator.StopMonitoring()
	logrus.Infof("[5/7] ✓ Monitoring stopped (%v)", time.Since(stepStart))

	// Disconnect all managers
	stepStart = time.Now()
	a.coordinator.DisconnectAll(ctx)
	logrus.Infof("[6/7] ✓ All managers disconnected (%v)", time.Since(stepStart))

	// Close database
	stepStart = time.Now()
	if err := a.db.Close(); err != nil {
		logrus.Errorf("[7/7] ✗ Failed to close database (%v): %v", time.Since(stepStart), err)
	} else {
		logrus.Infof("[7/7] ✓ Database closed (%v)", time.Since(stepStart))
	}

	logrus.Infof("✓ Server exited gracefully (total: %v)", time.Since(totalStart))
	return nil
}

func (a *Application) ensureApplicationEncryptionKey(ctx context.Context) (string, error) {
	key := strings.TrimSpace(a.config.Security.EncryptionKey)
	if key != "" {
		if err := a.persistSystemKey(ctx, "encryption_key", key, true); err != nil {
			return "", err
		}
		return key, nil
	}

	dbKey, err := a.getSystemConfigString(ctx, "encryption_key")
	if err != nil {
		return "", fmt.Errorf("failed to load encryption key: %w", err)
	}
	if dbKey != "" {
		a.config.Security.EncryptionKey = dbKey
		return dbKey, nil
	}

	legacyKey, err := a.getLegacyEncryptionKey(ctx)
	if err != nil {
		return "", err
	}
	if legacyKey != "" {
		a.config.Security.EncryptionKey = legacyKey
		if err := a.persistSystemKey(ctx, "encryption_key", legacyKey, true); err != nil {
			logrus.Warnf("failed to sync legacy encryption key: %v", err)
		}
		return legacyKey, nil
	}

	generated, err := crypto.GenerateKeyBase64()
	if err != nil {
		return "", fmt.Errorf("failed to generate encryption key: %w", err)
	}

	if err := a.persistSystemKey(ctx, "encryption_key", generated, true); err != nil {
		return "", fmt.Errorf("failed to persist encryption key: %w", err)
	}

	a.config.Security.EncryptionKey = generated
	logrus.Info("Generated new security encryption key")
	return generated, nil
}

func (a *Application) ensureDatabaseCredentialKey(ctx context.Context) (string, error) {
	key := strings.TrimSpace(a.config.DatabaseManagement.CredentialKey)
	if key != "" {
		if err := a.persistSystemKey(ctx, "database_credential_key", key, true); err != nil {
			return "", err
		}
		return key, nil
	}

	dbKey, err := a.getSystemConfigString(ctx, "database_credential_key")
	if err != nil {
		return "", fmt.Errorf("failed to load database credential key: %w", err)
	}
	if dbKey != "" {
		a.config.DatabaseManagement.CredentialKey = dbKey
		return dbKey, nil
	}

	generated, err := crypto.GenerateKeyBase64()
	if err != nil {
		return "", fmt.Errorf("failed to generate database credential key: %w", err)
	}

	if err := a.persistSystemKey(ctx, "database_credential_key", generated, true); err != nil {
		return "", fmt.Errorf("failed to persist database credential key: %w", err)
	}

	a.config.DatabaseManagement.CredentialKey = generated
	logrus.Info("Generated new database credential key")
	return generated, nil
}

func (a *Application) persistSystemKey(ctx context.Context, keyName, value string, sensitive bool) error {
	existing, err := a.getSystemConfigString(ctx, keyName)
	if err != nil {
		return err
	}
	if existing != "" && existing != value {
		return fmt.Errorf("%s mismatch between configuration and system store", keyName)
	}
	if existing == "" {
		return a.upsertSystemConfigString(ctx, keyName, value, sensitive)
	}
	return nil
}

func (a *Application) getSystemConfigString(ctx context.Context, key string) (string, error) {
	var cfg models.SystemConfig
	if err := a.db.DB.WithContext(ctx).Where("key = ?", key).First(&cfg).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return "", nil
		}
		return "", err
	}
	if raw, ok := cfg.Value["value"]; ok {
		if str, ok := raw.(string); ok {
			return strings.TrimSpace(str), nil
		}
	}
	return "", nil
}

func (a *Application) upsertSystemConfigString(ctx context.Context, key string, value string, sensitive bool) error {
	db := a.db.DB.WithContext(ctx)
	var cfg models.SystemConfig
	err := db.Where("key = ?", key).First(&cfg).Error
	if errors.Is(err, gorm.ErrRecordNotFound) {
		cfg = models.SystemConfig{
			Key:         key,
			Value:       models.JSONB{"value": value},
			ValueType:   "string",
			IsSensitive: sensitive,
		}
		return db.Create(&cfg).Error
	}
	if err != nil {
		return err
	}
	cfg.Value = models.JSONB{"value": value}
	if sensitive && !cfg.IsSensitive {
		cfg.IsSensitive = true
	}
	return db.Save(&cfg).Error
}

func (a *Application) getLegacyEncryptionKey(ctx context.Context) (string, error) {
	if !a.db.DB.Migrator().HasTable("system_config") {
		return "", nil
	}
	var legacy struct {
		EncryptionKey string `gorm:"column:encryption_key"`
	}
	if err := a.db.DB.WithContext(ctx).Table("system_config").Select("encryption_key").First(&legacy).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return "", nil
		}
		return "", err
	}
	return strings.TrimSpace(legacy.EncryptionKey), nil
}

// setupStaticFiles configures static file serving from embedded filesystem
func (a *Application) setupStaticFiles(router *gin.Engine) {
	// Serve assets directory
	assetsFS, err := fs.Sub(a.staticFS, "assets")
	if err != nil {
		logrus.Warnf("Failed to create assets sub-filesystem: %v", err)
	} else {
		router.StaticFS("/assets", http.FS(assetsFS))
	}

	// Serve index.html for all non-API routes (SPA catch-all)
	router.NoRoute(func(c *gin.Context) {
		data, err := a.staticFS.ReadFile("index.html")
		if err != nil {
			c.String(http.StatusNotFound, "404 page not found")
			return
		}
		c.Data(http.StatusOK, "text/html; charset=utf-8", data)
	})
}

// restartProcess restarts the current process
func (a *Application) restartProcess() error {
	executable, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to get executable path: %w", err)
	}

	// Get current process arguments
	args := os.Args

	// Get current environment
	env := os.Environ()

	// Execute the new process, replacing the current one
	// This works on Unix-like systems (Linux, macOS)
	return syscall.Exec(executable, args, env)
}

// registerScheduledTasks registers all scheduled tasks to the scheduler
// T027: Migrate existing tasks (alert_processing, database_audit_cleanup) to enhanced Scheduler
func (a *Application) registerScheduledTasks(ctx context.Context) error {
	logrus.Info("Registering scheduled tasks...")

	// Create necessary repositories for tasks
	alertRepo := repository.NewAlertRepository(a.db.DB)
	metricsRepo := repository.NewMetricsRepository(a.db.DB)
	auditEventRepo := repository.NewAuditEventRepository(a.db.DB)

	// Create NotificationService for AlertProcessor
	notificationSvc := notification.NewNotificationService()

	// Create AlertProcessor
	alertProcessor := alert.NewAlertProcessor(alertRepo, metricsRepo, notificationSvc, a.coordinator)

	// Task 1: Alert Processing (runs every 5 minutes)
	// T027: Use AddCron() method with cron expression
	alertTask := scheduler.NewAlertTask(alertProcessor)
	if err := a.scheduler.AddCron(
		alertTask.Name(),
		"*/5 * * * *", // Every 5 minutes
		alertTask,
	); err != nil {
		return fmt.Errorf("failed to register alert_processing task: %w", err)
	}
	logrus.Info("alert_processing task registered successfully")

	// Task 2: Database Audit Cleanup (runs daily at 2 AM)
	// T027: Use AddCron() method with cron expression
	retentionDays := 90 // Default retention period
	if a.config.Audit.RetentionDays > 0 {
		retentionDays = a.config.Audit.RetentionDays
	}

	auditCleanupTask := scheduler.NewDatabaseAuditCleanupTask(auditEventRepo, retentionDays)
	if err := a.scheduler.AddCron(
		auditCleanupTask.Name(),
		"0 2 * * *", // Daily at 2 AM
		auditCleanupTask,
	); err != nil {
		return fmt.Errorf("failed to register database_audit_cleanup task: %w", err)
	}
	logrus.Info("database_audit_cleanup task registered successfully")

	// Task 3: Host Expiry Check (runs daily at midnight)
	// Check host expiry dates and generate alerts
	hostRepo := repository.NewHostRepository(a.db.DB)
	monitorAlertRepo := repository.NewMonitorAlertRepository(a.db.DB)
	expiryScheduler := host.NewExpiryScheduler(hostRepo, monitorAlertRepo, a.db.DB)

	hostExpiryTask := scheduler.NewHostExpiryCheckTask(expiryScheduler)
	if err := a.scheduler.AddCron(
		hostExpiryTask.Name(),
		"0 0 * * *", // Daily at midnight
		hostExpiryTask,
	); err != nil {
		return fmt.Errorf("failed to register host_expiry_check task: %w", err)
	}
	logrus.Info("host_expiry_check task registered successfully")

	// Task 4: Cluster Health Check (runs every 5 minutes)
	// Check Kubernetes cluster health status
	if a.clusterHealthService != nil {
		clusterHealthTask := scheduler.NewClusterHealthCheckTask(a.clusterHealthService)
		if err := a.scheduler.AddCron(
			clusterHealthTask.Name(),
			"*/5 * * * *", // Every 5 minutes
			clusterHealthTask,
		); err != nil {
			return fmt.Errorf("failed to register cluster_health_check task: %w", err)
		}
		logrus.Info("cluster_health_check task registered successfully")
	}

	// Task 5: Docker Health Check (T030 - runs every 60 seconds)
	// Check Docker instance health status via Agent gRPC
	dockerInstanceRepo := repository.NewDockerInstanceRepository(a.db.DB)
	dockerForwarder := dockerservices.NewAgentForwarder(a.db.DB)
	dockerHealthService := dockerservices.NewDockerHealthService(dockerInstanceRepo, dockerForwarder, a.db.DB)

	dockerHealthTask := scheduler.NewDockerHealthCheckTask(dockerHealthService)
	if err := a.scheduler.AddCron(
		dockerHealthTask.Name(),
		"*/1 * * * *", // Every 1 minute (60 seconds)
		dockerHealthTask,
	); err != nil {
		return fmt.Errorf("failed to register docker_health_check task: %w", err)
	}
	logrus.Info("docker_health_check task registered successfully")

	// Task 6: Docker Audit Cleanup (T031 - runs daily at 2 AM)
	// Clean up old Docker operation audit logs
	auditLogRepo := repository.NewAuditLogRepository(a.db.DB)
	dockerAuditRetention := 90 // Default 90 days retention
	if a.config.Audit.RetentionDays > 0 {
		dockerAuditRetention = a.config.Audit.RetentionDays
	}

	dockerAuditCleanupTask := scheduler.NewDockerAuditCleanupTask(auditLogRepo, dockerAuditRetention)
	if err := a.scheduler.AddCron(
		dockerAuditCleanupTask.Name(),
		"0 2 * * *", // Daily at 2 AM
		dockerAuditCleanupTask,
	); err != nil {
		return fmt.Errorf("failed to register docker_audit_cleanup task: %w", err)
	}
	logrus.Info("docker_audit_cleanup task registered successfully")

	logrus.Infof("Successfully registered %d scheduled tasks", 6)
	return nil
}
