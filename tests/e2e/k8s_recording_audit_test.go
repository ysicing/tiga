// Code generated by spec-kit:implement; DO NOT EDIT.
// This file was generated at 2025-10-29 22:15:00
// Source: .claude/specs/010-k8s-pod-009/tasks.md (task: T038)

package e2e

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ysicing/tiga/internal/models"
	"github.com/ysicing/tiga/internal/repository"
)

// TestK8sNodeTerminalRecordingE2E tests end-to-end K8s node terminal recording flow
func TestK8sNodeTerminalRecordingE2E(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	ctx := context.Background()
	recordingRepo := repository.NewTerminalRecordingRepository(nil)

	// Step 1: Create a node terminal recording
	userID := uuid.New()
	clusterID := "test-cluster"
	nodeName := "test-node"

	// Simulate recording creation
	recording := &models.TerminalRecording{
		ID:              uuid.New(),
		SessionID:       uuid.New(),
		UserID:          userID,
		RecordingType:   models.RecordingTypeK8sNode,
		Title:           "Node Terminal - test-node",
		Status:          "active",
		StartTime:       time.Now(),
		DurationSeconds: 0,
	}

	err := recordingRepo.Create(ctx, recording)
	require.NoError(t, err, "Failed to create recording")

	// Step 2: Retrieve the recording
	retrieved, err := recordingRepo.GetByID(ctx, recording.ID)
	require.NoError(t, err, "Failed to retrieve recording")
	assert.Equal(t, models.RecordingTypeK8sNode, retrieved.RecordingType)
	assert.Equal(t, userID, retrieved.UserID)

	// Step 3: Update recording status
	retrieved.Status = "stopped"
	retrieved.EndTime = time.Now()
	retrieved.DurationSeconds = int64(retrieved.EndTime.Sub(retrieved.StartTime).Seconds())

	err = recordingRepo.Update(ctx, retrieved)
	require.NoError(t, err, "Failed to update recording")

	// Step 4: Verify update
	updated, err := recordingRepo.GetByID(ctx, recording.ID)
	require.NoError(t, err, "Failed to retrieve updated recording")
	assert.Equal(t, "stopped", updated.Status)
	assert.True(t, updated.DurationSeconds > 0)

	// Step 5: Filter recordings by K8s node
	filter := &repository.TerminalRecordingFilter{
		RecordingTypes: []string{models.RecordingTypeK8sNode},
	}

	recordings, total, err := recordingRepo.List(ctx, filter)
	require.NoError(t, err, "Failed to list recordings")
	assert.Greater(t, total, int64(0), "Should have at least one recording")

	// Step 6: Cleanup
	err = recordingRepo.Delete(ctx, recording.ID)
	require.NoError(t, err, "Failed to delete recording")

	// Verify deletion
	_, err = recordingRepo.GetByID(ctx, recording.ID)
	assert.Error(t, err, "Recording should be deleted")
}

// TestK8sPodTerminalRecordingE2E tests end-to-end K8s pod terminal recording flow
func TestK8sPodTerminalRecordingE2E(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	ctx := context.Background()
	recordingRepo := repository.NewTerminalRecordingRepository(nil)

	// Step 1: Create a pod terminal recording
	userID := uuid.New()
	clusterID := "test-cluster"
	namespace := "default"
	podName := "test-pod"
	containerName := "test-container"

	recording := &models.TerminalRecording{
		ID:              uuid.New(),
		SessionID:       uuid.New(),
		UserID:          userID,
		RecordingType:   models.RecordingTypeK8sPod,
		Title:           "Pod Terminal - default/test-pod/test-container",
		Status:          "active",
		StartTime:       time.Now(),
		DurationSeconds: 0,
	}

	err := recordingRepo.Create(ctx, recording)
	require.NoError(t, err, "Failed to create recording")

	// Step 2: Retrieve and validate recording
	retrieved, err := recordingRepo.GetByID(ctx, recording.ID)
	require.NoError(t, err, "Failed to retrieve recording")
	assert.Equal(t, models.RecordingTypeK8sPod, retrieved.RecordingType)

	// Step 3: Filter recordings by namespace and pod
	filter := &repository.TerminalRecordingFilter{
		RecordingTypes: []string{models.RecordingTypeK8sPod},
		TypeMetadata: map[string]interface{}{
			"namespace": namespace,
			"pod_name":  podName,
		},
	}

	recordings, total, err := recordingRepo.List(ctx, filter)
	require.NoError(t, err, "Failed to list recordings")
	assert.Greater(t, total, int64(0), "Should have at least one recording")

	// Step 4: Cleanup
	err = recordingRepo.Delete(ctx, recording.ID)
	require.NoError(t, err, "Failed to delete recording")
}

// TestK8sAuditEventE2E tests end-to-end K8s audit event flow
func TestK8sAuditEventE2E(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	ctx := context.Background()
	auditRepo := repository.NewAuditEventRepository(nil)

	// Step 1: Create a K8s resource operation audit event
	event := &models.AuditEvent{
		ID:           uuid.New().String(),
		Timestamp:    time.Now().UnixMilli(),
		Action:       models.ActionCreateResource,
		ResourceType: models.ResourceTypeDeployment,
		Subsystem:    models.SubsystemKubernetes,
		UserID:       "test-user",
		Username:     "test",
		ClientIP:     "127.0.0.1",
		ClusterID:    "test-cluster",
		Namespace:    "default",
		ResourceName: "test-deployment",
	}

	err := auditRepo.Create(ctx, event)
	require.NoError(t, err, "Failed to create audit event")

	// Step 2: Retrieve the audit event
	uid, _ := uuid.Parse(event.ID)
	retrieved, err := auditRepo.GetByID(ctx, uid)
	require.NoError(t, err, "Failed to retrieve audit event")
	assert.Equal(t, models.SubsystemKubernetes, retrieved.Subsystem)
	assert.Equal(t, models.ActionCreateResource, retrieved.Action)

	// Step 3: Filter audit events by K8s subsystem
	filter := &repository.AuditEventFilter{
		Subsystems: []models.Subsystem{models.SubsystemKubernetes},
		ClusterID:  stringPtr("test-cluster"),
	}

	events, total, err := auditRepo.List(ctx, filter)
	require.NoError(t, err, "Failed to list audit events")
	assert.Greater(t, total, int64(0), "Should have at least one audit event")

	// Step 4: Create a terminal access audit event
	terminalEvent := &models.AuditEvent{
		ID:           uuid.New().String(),
		Timestamp:    time.Now().UnixMilli(),
		Action:       models.ActionNodeTerminalAccess,
		ResourceType: models.ResourceTypeK8sNode,
		Subsystem:    models.SubsystemKubernetes,
		UserID:       "test-user",
		Username:     "test",
		ClientIP:     "127.0.0.1",
		ClusterID:    "test-cluster",
		Namespace:    "",
		ResourceName: "test-node",
	}

	err = auditRepo.Create(ctx, terminalEvent)
	require.NoError(t, err, "Failed to create terminal access audit event")

	// Step 5: Filter by action type
	filter.Actions = []models.Action{models.ActionNodeTerminalAccess}
	events, total, err = auditRepo.List(ctx, filter)
	require.NoError(t, err, "Failed to list terminal access events")
	assert.Greater(t, total, int64(0), "Should have at least one terminal access event")

	// Step 6: Cleanup
	err = auditRepo.Delete(ctx, uid)
	require.NoError(t, err, "Failed to delete audit event")

	terminalUID, _ := uuid.Parse(terminalEvent.ID)
	err = auditRepo.Delete(ctx, terminalUID)
	require.NoError(t, err, "Failed to delete terminal access event")
}

// TestK8sRecordingCleanupE2E tests end-to-end cleanup flow
func TestK8sRecordingCleanupE2E(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	ctx := context.Background()
	recordingRepo := repository.NewTerminalRecordingRepository(nil)

	// Create expired recordings
	expiredRecordings := make([]*models.TerminalRecording, 5)
	for i := 0; i < 5; i++ {
		recording := &models.TerminalRecording{
			ID:              uuid.New(),
			RecordingType:   models.RecordingTypeK8sNode,
			Title:           "Expired Recording",
			Status:          "stopped",
			StartTime:       time.Now().AddDate(0, 0, -100),
			EndTime:         time.Now().AddDate(0, 0, -100),
			DurationSeconds: 3600,
		}
		err := recordingRepo.Create(ctx, recording)
		require.NoError(t, err, "Failed to create expired recording")
		expiredRecordings[i] = recording
	}

	// Create recent recording
	recentRecording := &models.TerminalRecording{
		ID:              uuid.New(),
		RecordingType:   models.RecordingTypeK8sPod,
		Title:           "Recent Recording",
		Status:          "stopped",
		StartTime:       time.Now(),
		EndTime:         time.Now(),
		DurationSeconds: 3600,
	}
	err := recordingRepo.Create(ctx, recentRecording)
	require.NoError(t, err, "Failed to create recent recording")

	// Find expired recordings
	expired, err := recordingRepo.FindExpired(ctx, 90, 100)
	require.NoError(t, err, "Failed to find expired recordings")
	assert.Equal(t, 5, len(expired), "Should find 5 expired recordings")

	// Verify recent recording is not in expired list
	for _, exp := range expired {
		assert.NotEqual(t, recentRecording.ID, exp.ID, "Recent recording should not be expired")
	}

	// Cleanup: delete expired recordings
	for _, exp := range expired {
		err := recordingRepo.Delete(ctx, exp.ID)
		require.NoError(t, err, "Failed to delete expired recording")
	}

	// Verify recent recording still exists
	_, err = recordingRepo.GetByID(ctx, recentRecording.ID)
	require.NoError(t, err, "Recent recording should still exist")

	// Cleanup recent recording
	err = recordingRepo.Delete(ctx, recentRecording.ID)
	require.NoError(t, err, "Failed to delete recent recording")
}

func stringPtr(s string) *string {
	return &s
}
